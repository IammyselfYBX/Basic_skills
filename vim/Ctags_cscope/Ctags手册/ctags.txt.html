<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>~/ctags.txt.html</title>
<meta name="Generator" content="Vim/8.2">
<meta name="plugin-version" content="vim8.1_v2">
<meta name="syntax" content="none">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,expand_tabs,prevent_copy=,use_input_for_pc=fallback">
<meta name="colorscheme" content="none">
<style>
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #ffffff; background-color: #000000; }
body { font-family: monospace; color: #ffffff; background-color: #000000; }
* { font-size: 1em; }
-->
</style>
</head>
<body>
<pre id='vimCodeElement'>
CTAGS(1)                                                        Universal-ctags                                                       CTAGS(1)

NAME
       ctags - Generate tag files for source code

SYNOPSIS
       ctags [options] [source_file(s)]
       etags [options] [source_file(s)]

DESCRIPTION
       The  ctags  and etags programs (hereinafter collectively referred to as ctags, except where distinguished) generate an index (or &quot;tag&quot;)
       file for a variety of language objects found in source file(s). This tag file allows these items to be quickly and easily located by  a
       text  editor  or  other utilities (client tools). A tag signifies a language object for which an index entry is available (or, alterna‐
       tively, the index entry created for that object).

       Alternatively, ctags can generate a cross reference file which lists, in human readable form, information about  the  various  language
       objects found in a set of source files.

       Tag  index  files  are  supported  by numerous editors, which allow the user to locate the object associated with a name appearing in a
       source file and jump to the file and line which defines the name. See the manual of your favorite editor about utilizing ctags  command
       and the tag index files in the editor.

       ctags  is  capable  of  generating  different kinds of tags for each of many different languages. For a complete list of supported lan‐
       guages, the names by which they are recognized, and the kinds of tags which are  generated  for  each,  see  the  --list-languages  and
       --list-kinds-full options.

       This  man  page  describes Universal-ctags, an implementation of ctags derived from Exuberant-ctags. The major incompatible changes be‐
       tween Universal-ctags and Exuberant-ctags are enumerated in ctags-incompatibilities(7).

       One of the advantages of Exuberant-ctags is that it allows a user to define a new parser from the command line. Extending this capabil‐
       ity is one of the major features of Universal-ctags. ctags-optlib(7) describes how the capability is extended.

       Newly  introduced  experimental  features  are  not  explained  here. If you are interested in such features and ctags internals, visit
       <a href="https://docs.ctags.io/en/latest/">https://docs.ctags.io/en/latest/</a>.

SOURCE FILES
       Unless the --language-force option is specified, the language of each source file is automatically selected based  upon  a  mapping  of
       file  names to languages. The mappings in effect for each language may be displayed using the --list-maps option and may be changed us‐
       ing the --langmap or --map-&lt;LANG&gt; options.

       If the name of a file is not mapped to a language, ctags tries to heuristically guess the language for the file by inspecting its  con‐
       tent. See &quot;Determining file language&quot;.

       All  files that have no file name mapping and no guessed parser are ignored. This permits running ctags on all files in either a single
       directory (e.g.  &quot;ctags *&quot;), or on all files in an entire source directory tree (e.g. &quot;ctags -R&quot;), since only those files  whose  names
       are mapped to languages will be scanned.

       The same extensions are mapped to multiple parsers. For example, &quot;.h&quot; are mapped to C++, C and ObjectiveC. These mappings can cause is‐
       sues. ctags tries to select the proper parser for the source file by applying heuristics to its content, however it is not perfect.  In
       case  of  issues one can use --language-force=language, --langmap=map[,map[...]], or the --map-&lt;LANG&gt;=-pattern|extension options. (Some
       of the heuristics are applied whether --guess-language-eagerly is given or not.)

   Determining file language
       If ctags cannot select a parser from the mapping of file names, various heuristic tests are conducted to determine the language:

       template file name testing
              If the file name has an &quot;.in&quot; extension, ctags applies the mapping to the file name without the extension.  For  example,  &quot;con‐
              fig.h&quot; is tested for a file named &quot;config.h.in&quot;.

       interpreter testing
              The  first line of the file is checked to see if the file is a &quot;#!&quot;  script for a recognized language.  ctags looks for a parser
              having the same name.

              If ctags finds no such parser, ctags looks for the name in alias lists. For example, consider if the first line is  &quot;#!/bin/sh&quot;.
              Though  ctags  has  a  &quot;shell&quot; parser, it doesn't have a &quot;sh&quot; parser. However, &quot;sh&quot; is listed as an alias for &quot;shell&quot;, therefore
              ctags selects the &quot;shell&quot; parser for the file.

              An exception is &quot;env&quot;. If &quot;env&quot; is specified, ctags reads more lines to find real interpreter specification.

              To  display  the  list  of  aliases,  use  --list-aliases  option.   To  add/remove  an  item  to/from   the   list,   use   the
              --alias-&lt;LANG&gt;=[+|-]aliasPattern option.

       zsh autoload tag testing
              If the first line starts with &quot;#compdef&quot; or &quot;#autoload&quot;, ctags regards the line as &quot;zsh&quot;.

       emacs mode at the first line testing
              The  Emacs editor has multiple editing modes specialized for programming languages. Emacs can recognize a marker called modeline
              in a file and utilize the marker for the mode selection. This heuristic test does the same as what Emacs does.

              ctags treats MODE as a name of interpreter and applies the same rule of &quot;interpreter&quot; testing if the first line has one  of  the
              following patterns:

                 -*- mode: MODE -*-

              or

                 -*- MODE -*-

       emacs mode at the EOF testing
              Emacs  editor  recognizes another marker at the end of file as a mode specifier. This heuristic test does the same as what Emacs
              does.

              ctags treats MODE as a name of an interpreter and applies the same rule of &quot;interpreter&quot; heuristic testing, if the lines at  the
              tail of the file have the following pattern:

                 Local Variables:
                 ...
                 mode: MODE
                 ...
                 End:

              3000 characters are sought from the end of file to find the pattern.

       vim modeline testing
              Like  the modeline of the Emacs editor, Vim editor has the same concept.  ctags treats TYPE as a name of interpreter and applies
              the same rule of &quot;interpreter&quot; heuristic testing if the last 5 lines of the file have one of the following patterns:

                 filetype=TYPE

              or

                 ft=TYPE

       PHP marker testing
              If the first line is started with &quot;&lt;?php&quot;, ctags regards the line as &quot;php&quot;.

       Looking into the file contents is a more expensive operation than file name matching. So ctags runs the testings in limited conditions.
       &quot;interpreter&quot;  testing  is enabled only when a file is an executable or the --guess-language-eagerly (-G in short) option is given. The
       other heuristic tests are enabled only when -G option is given.

       The --print-language option can be used just to print the results of parser selections for given files instead  of  generating  a  tags
       file.

       Examples:

          $ ctags --print-language config.h.in input.m input.unknown
          config.h.in: C++
          input.m: MatLab
          input.unknown: NONE

       NONE means that ctags does not select any parser for the file.

TAG ENTRIES
       A  tag is an index for a language object. The concept of a tag and related items in Exuberant-ctags are refined and extended in Univer‐
       sal-ctags.

       A tag is categorized into definition tags or reference tags.  In general, Exuberant-ctags only tags definitions  of  language  objects:
       places  where newly named language objects are introduced.  Universal-ctags, on the other hand, can also tag references of language ob‐
       jects: places where named language objects are used. However, support for generating reference tags is new and limited to specific  ar‐
       eas of specific languages in the current version.

   Fields
       A  tag can record various information, called fields. The essential fields are: name of language objects, input, pattern, and line. in‐
       put: is the name of source file where name: is defined or referenced. pattern: can be used to search the name in input:.  line  is  the
       line number where name: is defined or referenced in input:.

       ctags offers extension fields. See also the descriptions of --list-fields option and --fields option.

   Kinds
       kind:  is  a  field  which represents the kind of language object specified by a tag. Kinds used and defined are very different between
       parsers.  For  example,  C  language  defines  &quot;macro&quot;,  &quot;function&quot;,  &quot;variable&quot;,  &quot;typedef&quot;,  etc.  See  also  the   descriptions   of
       --list-kinds-full option and --kinds-&lt;LANG&gt; option.

   Extras
       Generally, ctags tags only language objects appearing in source files, as is. In other words, a value for a name: field should be found
       on the source file associated with the name:. An &quot;extra&quot; type tag (extra) is for tagging a language object with a  processed  name,  or
       for  tagging  something  not associated with a language object. A typical extra tag is &quot;qualified&quot;, which tags a language object with a
       class-qualified or scope-qualified name.

       The following example demonstrates the &quot;qualified&quot; extra tag.

          package Bar;
          import Baz;

          class Foo {
                  // ...
          }

       For the above source file, ctags tags &quot;Bar&quot; and &quot;Foo&quot; by default.  If the &quot;qualified&quot; extra is enabled from  the  command  line  (--ex‐
       tras=+q), then &quot;Bar.Foo&quot; is also tagged even though the string &quot;Bar.Foo&quot; is not in the source code.

       See also the descriptions of --list-extras option and --extras option in &quot;OPTION ITEMS&quot;.

   Roles
       Role  is a newly introduced concept in Universal-ctags. Role is a concept associated with reference tags, and is not implemented widely
       yet.

       As described previously in &quot;Kinds&quot;, the &quot;kind&quot; field represents the type of language object specified with a tag, such  as  a  function
       vs.  a  variable.  Specific kinds are defined for reference tags, such as the C++ kind &quot;header&quot; for header file, or Java kind &quot;package&quot;
       for package statements. For such reference kinds, a &quot;roles&quot; field can be added to distinguish the role of the reference kind. In  other
       words,  the  &quot;kind&quot;  field identifies the &quot;what&quot; of the language object, whereas the &quot;roles&quot; field identifies the &quot;how&quot; of a referenced
       language object. Roles are only used with specific kinds.

       For example, for the source file used for demonstrating in the &quot;Extras&quot; subsection, &quot;Baz&quot; is tagged as a reference tag with kind &quot;pack‐
       age&quot;  and with role &quot;imported&quot;. Another example is for a C++ &quot;header&quot; kind tag, generated by &quot;#include&quot; statements: the roles:system or
       roles:local fields will be added depending on whether the include file name begins with &quot;&lt;&quot; or not.

       See also the descriptions of --list-roles option.

   Language-specific fields and extras
       Exuberant-ctags has the concept of &quot;fields&quot; and &quot;extras&quot;. They are common between parsers of different languages.  Universal-ctags  ex‐
       tends this concept by providing language-specific fields and extras.

COMMAND LINE INTERFACE
       Despite the wealth of available options, defaults are set so that ctags is most commonly executed without any options (e.g.  &quot;ctags *&quot;,
       or &quot;ctags -R&quot;), which will create a tag file in the current directory for all recognized source files. The options described below  are
       provided merely to allow custom tailoring to meet special needs.

       Note that spaces separating the single-letter options from their parameters are optional.

       Note also that the boolean parameters to the long form options (those beginning with &quot;--&quot; and that take a &quot;[=yes|no]&quot; parameter) may be
       omitted, in which case &quot;=yes&quot; is implied. (e.g. --sort is equivalent to --sort=yes).  Note further that &quot;=1&quot;, &quot;=on&quot;,  and  &quot;=true&quot;  are
       considered synonyms for &quot;=yes&quot;, and that &quot;=0&quot;, &quot;=off&quot;, and &quot;=false&quot; are considered synonyms for &quot;=no&quot;.

       Some options are either ignored or useful only when used while running in etags mode (see -e option). Such options will be noted.

       Most  options may appear anywhere on the command line, affecting only those files which follow the option. A few options, however, must
       appear before the first file name and will be noted as such.

       Options taking language names will accept those names in either upper or lower case. See the --list-languages  option  for  a  complete
       list of the built-in language names.

   Letters and names
       Some  options  take  one-letter flags as parameters (e.g. --kinds-&lt;LANG&gt; option).  Specifying just letters help a user create a compli‐
       cated command line quickly.  However, a command line including sequences of one-letter flags becomes difficult to understand.

       Universal-ctags accepts long-name flags in addition to such one-letter flags. The long-name and one-letter flags can be mixed in an op‐
       tion  parameter  by surrounding each long-name by braces. Thus, for an example, the following three notations for --kinds-C option have
       the same meaning:

          --kinds-C=+pLl
          --kinds-C=+{prototype}{label}{local}
          --kinds-C=+{prototype}L{local}

       Note that braces may be meta characters in your shell. Put single quotes in such case.

       --list-... options shows one-letter flags and associated long-name flags.

   List options
       Universal-ctags introduces many --list-... options that provide the internal data of Universal-ctags. Both users and client  tools  may
       use the data. --with-list-header and --machinable options adjust the output of the most of --list-... options.

       The  default  setting (--with-list-header=yes and --machinable=no) is for using interactively from a terminal. The header that explains
       the meaning of columns is simply added to the output, and each column is aligned in all lines. The header line starts with a hash ('#')
       character.

       For  scripting  in  a client tool, --with-list-header=no and --machinable=yes may be useful. The header is not added to the output, and
       each column is separated by tab characters.

       Note the order of columns will change in the future release.  However, labels in the header will not change. So by scanning the header,
       a client tool can find the index for the target column.

OPTION ITEMS
       ctags has more options than listed here.  Options starting with an underscore character, such as --_echo=msg, are not listed here. They
       are experimental or for debugging purpose.

       -?     Equivalent to --help.

       -a     Equivalent to --append.

       -B     Use backward searching patterns (e.g. ?pattern?). [Ignored in etags mode]

       -D macro=definition
              Defines a C preprocessor macro. This emulates the behaviour of the corresponding gcc option. All types of macros are  supported,
              including  the  ones  with  parameters and variable arguments.  Stringification, token pasting and recursive macro expansion are
              also supported.  This extends the function provided by -I option.

       -e     Same as --output-format=etags.  Enable etags mode, which will create a tag file for use with the Emacs editor. Alternatively, if
              ctags is invoked by a name containing the string &quot;etags&quot; (either by renaming, or creating a link to, the executable), etags mode
              will be enabled.  This option must appear before the first file name.

       -f tagfile
              Use the name specified by tagfile for the tag file (default is &quot;tags&quot;, or &quot;TAGS&quot; when running in  etags  mode).  If  tagfile  is
              specified  as  &quot;-&quot;, then the tags are written to standard output instead. ctags will stubbornly refuse to take orders if tagfile
              exists and its first line contains something other than a valid tags line. This will save  your  neck  if  you  mistakenly  type
              &quot;ctags  -f  *.c&quot;,  which would otherwise overwrite your first C file with the tags generated by the rest! It will also refuse to
              accept a multi-character file name which begins with a '-' (dash) character, since this most likely means that you left out  the
              tag  file  name  and this option tried to grab the next option as the file name. If you really want to name your output tag file
              &quot;-ugly&quot;, specify it as &quot;./-ugly&quot;. This option must appear before the first file name. If this  option  is  specified  more  than
              once, only the last will apply.

       -F     Use forward searching patterns (e.g. /pattern/) (default). [Ignored in etags mode]

       -G     Equivalent to --guess-language-eagerly.

       -h list
              Specifies a list of file extensions, separated by periods, which are to be interpreted as include (or header) files. To indicate
              files having no extension, use a period not followed by a non-period character (e.g. &quot;.&quot;, &quot;..x&quot;, &quot;.x.&quot;). This  option  only  af‐
              fects  how  the scoping of particular kinds of tags are interpreted (i.e. whether or not they are considered as globally visible
              or visible only within the file in which they are defined); it does not map the extension to any particular  language.  Any  tag
              which  is located in a non-include file and cannot be seen (e.g. linked to) from another file is considered to have file-limited
              (e.g. static) scope. No kind of tag appearing in an include file will be considered to have file-limited  scope.  If  the  first
              character  in the list is a plus sign, then the extensions in the list will be appended to the current list; otherwise, the list
              will replace the current list. See, also, the --file-scope option. The default list is &quot;.h.H.hh.hpp.hxx.h++.inc.def&quot;. To restore
              the  default  list,  specify -h default. Note that if an extension supplied to this option is not already mapped to a particular
              language (see &quot;SOURCE FILES&quot;, above), you will also need to use either the --langmap or --language-force option.

       -I identifier-list
              Specifies a list of identifiers which are to be specially handled while parsing C and C++ source files. This option is  specifi‐
              cally  provided  to handle special cases arising through the use of preprocessor macros.  When the identifiers listed are simple
              identifiers, these identifiers will be ignored during parsing of the source files. If an identifier is suffixed with a '+' char‐
              acter,  ctags  will also ignore any parenthesis-enclosed argument list which may immediately follow the identifier in the source
              files. If two identifiers are separated with the '=' character, the first identifiers is replaced by the second identifiers  for
              parsing  purposes. The list of identifiers may be supplied directly on the command line or read in from a separate file.  If the
              first character of identifier-list is '@', '.' or a pathname separator ('/' or '\'), or the first two characters specify a drive
              letter  (e.g.  &quot;C:&quot;),  the parameter identifier-list will be interpreted as a filename from which to read a list of identifiers,
              one per input line.  Otherwise, identifier-list is a list of identifiers (or identifier pairs) to be specially handled, each de‐
              limited by either a comma or by white space (in which case the list should be quoted to keep the entire list as one command line
              argument). Multiple -I options may be supplied. To clear the list of ignore identifiers, supply a single dash (&quot;-&quot;) for  identi‐
              fier-list.

              This  feature  is  useful when preprocessor macros are used in such a way that they cause syntactic confusion due to their pres‐
              ence. Indeed, this is the best way of working around a number of problems caused by the presence  of  syntax-busting  macros  in
              source files (see &quot;CAVEATS&quot;).  Some examples will illustrate this point.

                 int foo ARGDECL4(void *, ptr, long int, nbytes)

              In the above example, the macro &quot;ARGDECL4&quot; would be mistakenly interpreted to be the name of the function instead of the correct
              name of &quot;foo&quot;. Specifying &quot;-I ARGDECL4&quot; results in the correct behavior.

                 /* creates an RCS version string in module */
                 MODULE_VERSION(&quot;$Revision$&quot;)

              In the above example the macro invocation looks too much like a function definition because it is not followed  by  a  semicolon
              (indeed, it could even be followed by a global variable definition that would look much like a K&amp;R style function parameter dec‐
              laration). In fact, this seeming function definition could possibly even cause the rest of the file to  be  skipped  over  while
              trying to complete the definition.  Specifying &quot;-I MODULE_VERSION+&quot; would avoid such a problem.

                 CLASS Example {
                         // your content here
                 };

              The  example  above  uses  &quot;CLASS&quot;  as a preprocessor macro which expands to something different for each platform. For instance
              CLASS may be defined as &quot;class __declspec(dllexport)&quot; on Win32 platforms and simply &quot;class&quot; on UNIX. Normally,  the  absence  of
              the C++ keyword &quot;class&quot; would cause the source file to be incorrectly parsed. Correct behavior can be restored by specifying &quot;-I
              CLASS=class&quot;.

       -L file
              Read from file a list of file names for which tags should be generated.  If file is specified as &quot;-&quot;, then file names  are  read
              from standard input. File names read using this option are processed following file names appearing on the command line. Options
              are also accepted in this input. If this option is specified more than once, only the last will apply. Note:  file  is  read  in
              line-oriented mode, where a new line is the only delimiter and non-trailing white space is considered significant, in order that
              file names containing spaces may be supplied (however, trailing white space is stripped from lines); this can affect how options
              are parsed if included in the input.

       -n     Equivalent to --excmd=number.

       -N     Equivalent to --excmd=pattern.

       -o tagfile
              Equivalent to -f tagfile.

       -R     Equivalent to --recurse.

       -u     Equivalent to --sort=no (i.e. &quot;unsorted&quot;).

       -V     Equivalent to --verbose.

       -w     This option is silently ignored for backward-compatibility with the ctags of SVR4 Unix.

       -x     Same  as --output-format=xref.  Print a tabular, human-readable cross reference (xref) file to standard output instead of gener‐
              ating a tag file. The information contained in the output includes: the tag name; the kind of tag; the line number,  file  name,
              and source line (with extra white space condensed) of the file which defines the tag. No tag file is written and all options af‐
              fecting tag file output will be ignored. Example applications for this feature are generating a listing of all functions located
              in  a source file (e.g. &quot;ctags -x --kinds-c=f file&quot;), or generating a list of all externally visible global variables located in
              a source file (e.g. &quot;ctags -x --kinds-c=v --file-scope=no file&quot;).  This option must appear before the first file name.

       --alias-&lt;LANG&gt;=[+|-]aliasPattern
              Adds ('+') or removes ('-') an alias pattern to a language specified with &lt;LANG&gt;. ctags  refers  to  the  alias  pattern  in  &quot;‐
              Determining file language&quot; stage.

              The  parameter aliasPattern is not a list. Use this option multiple times in a command line to add or remove multiple alias pat‐
              terns.

              To restore the default language aliases, specify &quot;default&quot; as the parameter aliasPattern. Using &quot;all&quot; for &lt;LANG&gt; has meaning  in
              following two cases:

              --alias-all=
                     This clears aliases setting of all languages.

              --alias-all=default
                     This restores the default languages aliases for all languages.

       --append[=yes|no]
              Indicates  whether tags generated from the specified files should be appended to those already present in the tag file or should
              replace them.  This option is &quot;no&quot; by default. This option must appear before the first file name.

       --etags-include=file
              Include a reference to file in the tag file. This option may be specified as many times as desired. This supports  Emacs'  capa‐
              bility to use a tag file which &quot;includes&quot; other tag files. [Available only in etags mode]

       --exclude=[pattern]
              Add  pattern  to  a list of excluded files and directories. This option may be specified as many times as desired. For each file
              name considered by ctags, each pattern specified using this option will  be  compared  against  both  the  complete  path  (e.g.
              some/path/base.ext)  and  the  base name (e.g. base.ext) of the file, thus allowing patterns which match a given file name irre‐
              spective of its path, or match only a specific path. If appropriate support is available from the runtime library of your C com‐
              piler,  then pattern may contain the usual shell wildcards (not regular expressions) common on Unix (be sure to quote the option
              parameter to protect the wildcards from being expanded by the shell before being passed to ctags; also be aware  that  wildcards
              can  match the slash character, '/').  You can determine if shell wildcards are available on your platform by examining the out‐
              put of the --list-features option, which will include &quot;wildcards&quot; in the compiled feature list; otherwise,  pattern  is  matched
              against file names using a simple textual comparison.

              If pattern begins with the character '@', then the rest of the string is interpreted as a file name from which to read exclusion
              patterns, one per line. If pattern is empty, the list of excluded patterns is cleared.

              Note that at program startup, the default exclude list contains names of common hidden and system  files,  patterns  for  binary
              files, and directories for which it is generally not desirable to descend while processing the --recurse option. To see the list
              of built-in exclude patterns, use --list-excludes.

       --excmd=type
              Determines the type of EX command used to locate tags in the source file. [Ignored in etags mode]

              The valid values for type (either the entire word or the first letter is accepted) are:

              number Use only line numbers in the tag file for locating tags. This has four advantages:

                     1. Significantly reduces the size of the resulting tag file.

                     2. Eliminates failures to find tags because the line defining the tag has changed, causing  the  pattern  match  to  fail
                        (note that some editors, such as vim, are able to recover in many such instances).

                     3. Eliminates finding identical matching, but incorrect, source lines (see &quot;BUGS&quot;).

                     4. Retains  separate entries in the tag file for lines which are identical in content. In pattern mode, duplicate entries
                        are dropped because the search patterns they generate are identical, making the duplicate entries useless.

                     However, this option has one significant drawback: changes to the source files can cause the line numbers recorded in the
                     tag  file  to no longer correspond to the lines in the source file, causing jumps to some tags to miss the target defini‐
                     tion by one or more lines. Basically, this option is best used when the source code to which it is applied is not subject
                     to change. Selecting this option type causes the following options to be ignored: -BF.

              pattern
                     Use  only search patterns for all tags, rather than the line numbers usually used for macro definitions. This has the ad‐
                     vantage of not referencing obsolete line numbers when lines have been added or removed since the tag file was generated.

              mixed  In this mode, patterns are generally used with a few exceptions.  For C, line numbers are used for macro definition tags.
                     This  was  the default format generated by the original ctags and is, therefore, retained as the default for this option.
                     For Fortran, line numbers are used for common blocks because their corresponding source lines  are  generally  identical,
                     making pattern searches useless for finding all matches.

              combine
                     Combine adjusted line number and pattern with a semicolon.  ctags adjusts the line number by decrementing or incrementing
                     (if -B option is given) one.  This adjustment helps a client tool like vim to search the pattern from the line before (or
                     after) the pattern starts.

       --extra=[+|-]flags|*
              Equivalent  to  --extras=[+|-]flags|*, which was introduced to make the option naming convention align to the other options like
              --kinds-&lt;LANG&gt;= and --fields=.

              This option is kept for backward-compatibility with Exuberant-ctags.

       --extras=[+|-]flags|*
              Specifies whether to include extra tag entries for certain kinds of information. See also &quot;Extras&quot; subsection to know  what  are
              kinds.

              The  parameter flags is a set of one-letter flags (and/or long-name flags), each representing one kind of extra tag entry to in‐
              clude in the tag file.  If flags is preceded by either the '+' or '-' character, the effect of each flag is added to, or removed
              from, those currently enabled; otherwise the flags replace any current settings. All entries are included  if '*' is given.

              This  --extras= option is for controlling extras common in all languages (or language-independent extras).  Universal-ctags also
              supports language-specific extras. (See &quot;Language-specific fields and extras&quot; about the concept).  Use  --extras-&lt;LANG&gt;=  option
              for controlling them.

              The meaning of major extras is as follows (one-letter flag/long-name flag):

              F/fileScope
                     Equivalent to --file-scope.

              f/inputFile
                     Include  an  entry  for the base file name of every source file (e.g. &quot;example.c&quot;), which addresses the first line of the
                     file.  If the end: field is enabled, the end line number of the file can be attached to the tag.

              p/pseudo
                     Include pseudo tags. Enabled by default unless the tag file is written to standard output.

              q/qualified
                     Include an extra class-qualified or namespace-qualified tag entry for each tag which is a member of a class  or  a  name‐
                     space.

                     This  may  allow easier location of a specific tags when multiple occurrences of a tag name occur in the tag file.  Note,
                     however, that this could potentially more than double the size of the tag file.

                     The actual form of the qualified tag depends upon the language from which the tag was derived (using a form that is  most
                     natural  for how qualified calls are specified in the language). For C++ and Perl, it is in the form &quot;class::member&quot;; for
                     Eiffel and Java, it is in the form &quot;class.member&quot;.

                     Note: Using backslash characters as separators forming qualified name in PHP. However, in tags output of Universal-ctags,
                     a backslash character in a name is escaped with a backslash character. See tags(5) about the escaping.

              r/reference
                     Include reference tags. See &quot;TAG ENTRIES&quot; about reference tags.

              Inquire the output of --list-extras option for the other minor extras.

       --extras-&lt;LANG&gt;=[+|-]flags|*
              Specifies  whether to include extra tag entries for certain kinds of information for language &lt;LANG&gt;. Universal-ctags introduces
              language-specific extras. (See &quot;Language-specific fields and extras&quot; about the concept). This option is for controlling them.

              Specifies &quot;all&quot; as &lt;LANG&gt; to apply the parameter flags to all languages; all extras are enabled with specifying '*' as  the  pa‐
              rameter  flags.  If specifying nothing as the parameter flags (&quot;--extras-all=&quot;), all extras are disabled. These two combinations
              are useful for testing.

              Check the output of the --list-extras=&lt;LANG&gt; option for the extras of specific language &lt;LANG&gt;.

       --fields=[+|-]flags|*
              Specifies which available extension fields are to be included in the tag entries (see &quot;TAG FILE FORMAT&quot;, below,  and,  &quot;Fields&quot;,
              above, for more information).

              The  parameter flags is a set of one-letter flags (and/or long-name flags), each representing one type of extension field to in‐
              clude.  Each letter or group of letters may be preceded by either '+' to add it to the default set, or '-' to exclude it. In the
              absence  of  any  preceding  '+'  or '-' sign, only those fields explicitly listed in flags will be included in the output (i.e.
              overriding the default set). All fields are included if '*' is given. This option is ignored if the  option  --format=1  (legacy
              tag file format) has been specified.

              This  --fields= option is for controlling fields common in all languages (or language-independent fields).  Universal-ctags also
              supports language-specific fields. (See &quot;Language-specific fields and extras&quot; about the concept).  Use  --fields-&lt;LANG&gt;=  option
              for controlling them.

              The meaning of major fields is as follows (one-letter flag/long-name flag):

              a/access
                     Access (or export) of class members

              e/end  End lines of various items

              f/file File-restricted scoping. Enabled by default.

              i/inherits
                     Inheritance information.

              k      Kind of tag as one-letter. Enabled by default.  Exceptionally this has no field name.  See also z/kind flag.

              K      Kind of tag as full name Exceptionally this has no field name.  See also z/kind flag.

              l/language
                     Language of source file containing tag

              m/implementation
                     Implementation information

              n/line Line number of tag definition

              p/scopeKind
                     Kind of scope as full name

              r/roles
                     Roles assigned to the tag.  For a definition tag, this field takes &quot;def&quot; as a value.

              s      Scope of tag definition. Enabled by default.  Exceptionally this has no name.  See also Z flag.

              S/signature
                     Signature of routine (e.g. prototype or parameter list)

              t/typeref
                     Type and name of a variable, typedef or return type of callable like function as &quot;typeref:&quot; field.  Enabled by default.

              z/kind Include the &quot;kind:&quot; key in kind field

              Z      Include the &quot;scope:&quot; key in scope field.  Exceptionally this has no name.

              Check the output of the --list-fields option for the other minor fields.

       --fields-&lt;LANG&gt;=[+|-]flags|*
              Specifies  which  language-specific  fields  are  to  be  included in the entries of the tag file. Universal-ctags supports lan‐
              guage-specific fields. (See &quot;Language-specific fields and extras&quot; about the concept). This option is for controlling them.

              Specify &quot;all&quot; as &lt;LANG&gt; to apply the parameter flags to all fields; all fields are enabled with specifying '*' as the  parameter
              flags.  If specifying nothing as the parameter flags (&quot;--fields-all=&quot;), all fields are disabled. These two combinations are use‐
              ful for testing.

       --file-scope[=yes|no]
              Indicates whether tags scoped only for a single file (i.e. tags which cannot be seen outside of the file in which they  are  de‐
              fined, such as &quot;static&quot; tags) should be included in the output. See, also, the -h option. This option is enabled by default.

              Universal-ctags  provides  an  alternative way to control this option, with the &quot;F/fileScope&quot; extra, and recommends users to use
              the extra. However, this extra can cause issues.  See ctags-incompatibilities(7).

       --filter[=yes|no]
              Makes ctags behave as a filter, reading source file names from standard input and printing their tags to standard  output  on  a
              file-by-file  basis. If --sort is enabled, tags are sorted only within the source file in which they are defined. File names are
              read from standard input in line-oriented input mode (see note for -L option) and only after file names listed  on  the  command
              line  or  from any file supplied using the -L option. When this option is enabled, the options -f, -o, and --totals are ignored.
              This option is quite esoteric and is disabled by default. This option must appear before the first file name.

       --filter-terminator=string
              Specifies a string to print to standard output following the tags for each file name parsed when the --filter option is enabled.
              This  may permit an application reading the output of ctags to determine when the output for each file is finished. Note that if
              the file name read is a directory and --recurse is enabled, this string will be printed only once at the end of all  tags  found
              for  by  descending  the  directory. This string will always be separated from the last tag line for the file by its terminating
              newline. This option is quite esoteric and is empty by default. This option must appear before the first file name.

       --format=level
              Change the format of the output tag file. Currently the only valid values for level are 1 or 2. Level 1 specifies  the  original
              tag  file  format  and  level 2 specifies a new extended format containing extension fields (but in a manner which retains back‐
              ward-compatibility with original vi(1) implementations). The default level is 2. This option must appear before the  first  file
              name. [Ignored in etags mode]

       --guess-language-eagerly
              Looks into the file contents for heuristically guessing the proper language parser.  See &quot;Determining file language&quot;.

       --help Prints to standard output a detailed usage description, and then exits.

       --help-full
              Prints   to   standard   output   a   detailed   usage   description   about   experimental  features,  and  then  exits.  Visit
              <a href="https://docs.ctags.io/en/latest/">https://docs.ctags.io/en/latest/</a> for information about the latest exciting experimental features.

       --if0[=yes|no]
              Indicates a preference as to whether code within an &quot;#if 0&quot;  branch  of  a  preprocessor  conditional  should  be  examined  for
              non-macro  tags  (macro tags are always included). Because the intent of this construct is to disable code, the default value of
              this option is no. Note that this indicates a preference only and does not guarantee skipping code within  an  &quot;#if  0&quot;  branch,
              since  the  fall-back  algorithm  used to generate tags when preprocessor conditionals are too complex follows all branches of a
              conditional. This option is disabled by default.

       --input-encoding=encoding
              Specifies the encoding of the input files.  If this option is specified, Universal-ctags converts the input from  this  encoding
              to the encoding specified by --output-encoding=encoding.

       --input-encoding-&lt;LANG&gt;=encoding
              Specifies a specific input encoding for LANG. It overrides the global default value given with --input-encoding.

       --kinddef-&lt;LANG&gt;=letter,name,description
              See ctags-optlib(7).  Be not confused this with --kinds-&lt;LANG&gt;.

       --kinds-&lt;LANG&gt;=[+|-]kinds|*
              Specifies  a  list  of language-specific kinds of tags (or kinds) to include in the output file for a particular language, where
              &lt;LANG&gt; is case-insensitive and is one of the built-in language names (see the --list-languages option for a complete list).  The
              parameter  kinds  is a group of one-letter flags (and/or long-name flags) designating kinds of tags (particular to the language)
              to either include or exclude from the output. The specific sets of flags recognized for each language, their  meanings  and  de‐
              faults  may  be list using the --list-kinds-full option. Each letter or group of letters may be preceded by either '+' to add it
              to, or '-' to remove it from, the default set. In the absence of any preceding '+' or '-'  sign,  only  those  kinds  explicitly
              listed in kinds will be included in the output (i.e. overriding the default for the specified language).

              Specify  '*' as the parameter to include all kinds implemented in &lt;LANG&gt; in the output. Furthermore if &quot;all&quot; is given as &lt;LANG&gt;,
              specification of the parameter kinds affects all languages defined in ctags. Giving &quot;all&quot; makes sense only when '*' is given  as
              the parameter kinds.

              As an example for the C language, in order to add prototypes and external variable declarations to the default set of tag kinds,
              but exclude macros, use &quot;--kinds-c=+px-d&quot;; to include only tags for functions, use &quot;--kinds-c=f&quot;.

              Some kinds of C and C++ languages are synchronized; enabling (or disabling) a kind in one language enables the kind  having  the
              same one-letter and long-name in the other language. See also the description of MASTER column of --list-kinds-full.

       --&lt;LANG&gt;-kinds=[+|-]kinds|*
              This option is obsolete. Use --kinds-&lt;LANG&gt;=... instead.

       --langdef=name
              See ctags-optlib(7).

       --langmap=map[,map[...]]
              Controls  how file names are mapped to languages (see the --list-maps option). Each comma-separated map consists of the language
              name (either a built-in or user-defined language), a colon, and a list of file extensions and/or file name patterns. A file  ex‐
              tension  is  specified  by  preceding the extension with a period (e.g. &quot;.c&quot;). A file name pattern is specified by enclosing the
              pattern in parentheses (e.g.  &quot;([Mm]akefile)&quot;).

              If appropriate support is available from the runtime library of your C compiler, then the file  name  pattern  may  contain  the
              usual  shell wildcards common on Unix (be sure to quote the option parameter to protect the wildcards from being expanded by the
              shell before being passed to ctags). You can determine if shell wildcards are available on your platform by examining the output
              of  the  --list-features  option, which will include &quot;wildcards&quot; in the compiled feature list; otherwise, the file name patterns
              are matched against file names using a simple textual comparison.

              When mapping a file extension with --langmap option, it will first be unmapped from any other  languages.  (--map-&lt;LANG&gt;  option
              provides more fine-grained control.)

              If the first character in a map is a plus sign ('+'), then the extensions and file name patterns in that map will be appended to
              the current map for that language; otherwise, the map will replace the current map.  For example, to  specify  that  only  files
              with extensions of .c and .x are to be treated as C language files, use &quot;--langmap=c:.c.x&quot;; to also add files with extensions of
              .j as Java language files, specify &quot;--langmap=c:.c.x,java:+.j&quot;. To map makefiles (e.g. files  named  either  &quot;Makefile&quot;,  &quot;make‐
              file&quot;,  or  having  the  extension &quot;.mak&quot;) to a language called &quot;make&quot;, specify &quot;--langmap=make:([Mm]akefile).mak&quot;. To map files
              having no extension, specify a period not followed by a non-period character (e.g. &quot;.&quot;, &quot;..x&quot;, &quot;.x.&quot;).

              To clear the mapping for a particular language (thus inhibiting automatic generation of tags  for  that  language),  specify  an
              empty  extension  list  (e.g. &quot;--langmap=fortran:&quot;).  To restore the default language mappings for a particular language, supply
              the keyword &quot;default&quot;  for  the  mapping.  To  specify  restore  the  default  language  mappings  for  all  languages,  specify
              &quot;--langmap=default&quot;.

              Note  that  file  name  patterns  are tested before file extensions when inferring the language of a file. This order of Univer‐
              sal-ctags is different from Exuberant-ctags. See ctags-incompatibilities(7) for the background of this incompatible change.

       --language-force=language
              By default, ctags automatically selects the language of a source file, ignoring those files whose language cannot be  determined
              (see &quot;SOURCE FILES&quot;, above). This option forces the specified language (case-insensitive; either built-in or user-defined) to be
              used for every supplied file instead of automatically selecting the language based upon its extension. In addition, the  special
              value &quot;auto&quot; indicates that the language should be automatically selected (which effectively disables this option).

       --languages=[+|-]list
              Specifies  the  languages  for  which  tag  generation is enabled, with list containing a comma-separated list of language names
              (case-insensitive; either built-in or user-defined). If the first language of list is not preceded by either a '+' or  '-',  the
              current  list  (the current settings of enabled/disabled languages managed in ctags internally) will be cleared before adding or
              removing the languages in list. Until a '-' is encountered, each language in the list will be added to the current list.  As ei‐
              ther  the  '+' or '-' is encountered in the list, the languages following it are added or removed from the current list, respec‐
              tively.  Thus, it becomes simple to replace the current list with a new one, or to add or  remove  languages  from  the  current
              list.

              The  actual  list  of  files  for  which  tags  will be generated depends upon the language extension mapping in effect (see the
              --langmap option). Note that the most of all languages, including user-defined languages, are enabled unless explicitly disabled
              using  this  option.  Language names included in list may be any built-in language or one previously defined with --langdef. The
              default is &quot;all&quot;, which is also accepted as a valid argument. See the --list-languages option for a list of  the  all  (built-in
              and user-defined) language names.

              Note  --languages= option works cumulative way; the option can be specified with different arguments multiple times in a command
              line.

       --license
              Prints a summary of the software license to standard output, and then exits.

       --line-directives[=yes|no]
              Specifies whether &quot;#line&quot; directives should be recognized. These are present in the output of preprocessors and contain the line
              number,  and  possibly the file name, of the original source file(s) from which the preprocessor output file was generated. When
              enabled, this option will cause ctags to generate tag entries marked with the file names and line  numbers  of  their  locations
              original source file(s), instead of their actual locations in the preprocessor output. The actual file names placed into the tag
              file will have the same leading path components as the preprocessor output file, since it is assumed that  the  original  source
              files  are located relative to the preprocessor output file (unless, of course, the #line directive specifies an absolute path).
              This option is off by default. Note: This option is generally only useful when used together with the  --excmd=number  (-n)  op‐
              tion.   Also,  you  may  have to use either the --langmap or --language-force option if the extension of the preprocessor output
              file is not known to ctags.

       --links[=yes|no]
              Indicates whether symbolic links (if supported) should be followed.  When disabled, symbolic links are ignored. This  option  is
              on by default.

       --list-aliases[=language|all]
              Lists  the  aliases for either the specified language or all languages, and then exits.  all is used as default value if the op‐
              tion argument is omitted.  The aliases are used when heuristically testing a language parser for a source file.

       --list-excludes
              Lists the current exclusion patterns used to exclude files.

       --list-extras[=language|all]
              Lists the extras recognized for either the specified language or all languages. See &quot;Extras&quot; subsection to know what are extras.
              all is used as default value if the option argument is omitted.

              An  extra  can  be  enabled or disabled with --extras= for common extras in all languages, or --extras-&lt;LANG&gt;= for the specified
              language.  These option takes one-letter flag or long-name flag as a parameter for specifying an extra.

              The meaning of columns are as follows:

              LETTER One-letter flag. '-' means the extra does not have one-letter flag.

              NAME   Long-name flag. The long-name is used in extras: field.

              ENABLED
                     Whether the extra is enabled or not. It takes &quot;yes&quot; or &quot;no&quot;.

              LANGUAGE
                     The name of language if the extra is owned by a parser.  &quot;NONE&quot; means the extra is common in parsers.

              DESCRIPTION
                     Human readable description for the extra.

       --list-features
              Lists the compiled features.

       --list-fields[=language|all]
              Lists the fields recognized for either the specified language or all languages. See &quot;Fields&quot; subsection to know what are fields.
              all is used as default value if the option argument is omitted.

              A field can be enabled or disabled with --fields= for common extras in all languages, or --fields-&lt;LANG&gt;= for the specified lan‐
              guage.  These option takes one-letter flags and/or long-name flags as a parameter for specifying fields.

              The meaning of columns are as follows:

              LETTER One-letter flag. '-' means the field does not have one-letter flag.

              NAME   Long-name of field.

              ENABLED
                     Whether the field is enabled or not. It takes &quot;yes&quot; or &quot;no&quot;.

              LANGUAGE
                     The name of language if the field is owned by a parser.  &quot;NONE&quot; means the extra is common in parsers.

              JSTYPE Json type used in printing the value of field when &quot;--output-format=json&quot; is specified.

                     Following characters are used for representing types.

                     s      string

                     i      integer

                     b      boolean (true or false)

                     The representation of this field and the output format used in &quot;--output-format=json&quot; are still experimental.

              FIXED  Whether this field can be disabled or not. Some fields are printed always in tags output. They have &quot;yes&quot;  as  the  value
                     for this column.

              DESCRIPTION
                     Human readable description for the field.

       --list-kinds[=language|all]
              Subset of --list-kinds-full. This option is kept for backward-compatibility with Exuberant-ctags.

              This  option  prints  only LETTER, DESCRIPTION, and ENABLED fields of --list-kinds-full output. However, the presentation of EN‐
              ABLED column is different from that of --list-kinds-full option; &quot;[off]&quot; follows after description if the kind is disabled,  and
              nothing follows     if enabled. The most of all kinds are enabled by default.

              The  critical  weakness  of  this  option  is  that  this  option  does  not  print the name of kind. Universal-ctags introduces
              --list-kinds-full because it considers that names are important.

              This option does not work with --machinable nor --with-list-header.

       --list-kinds-full[=language|all]
              Lists the tag kinds recognized for either the specified language or all languages, and then exits.  See  &quot;Kinds&quot;  subsection  to
              learn what kinds are.  all is used as default value if the option argument is omitted.

              Each kind of tag recorded in the tag file is represented by a one-letter flag, or a long-name flag. They are also used to filter
              the tags placed into the output through use of the --kinds-&lt;LANG&gt; option.

              The meaning of columns are as follows:

              LANGUAGE
                     The name of language having the kind.

              LETTER One-letter flag. This must be unique in a language.

              NAME   The long-name flag of the kind. This can be used as the alternative to the one-letter flag described above.  If  enabling
                     'K'  field  with  --fields=+K, ctags uses long-names instead of one-letters in tags output. To enable/disable a kind with
                     --kinds-&lt;LANG&gt; option, long-name surrounded by braces instead of one-letter. See &quot;Letters and names&quot;  for  details.  This
                     must be unique in a language.

              ENABLED
                     Whether the kind is enabled or not. It takes &quot;yes&quot; or &quot;no&quot;.

              REFONLY
                     Whether the kind is specialized for reference tagging or not.  If the column is &quot;yes&quot;, the kind is for reference tagging,
                     and it is never used for definition tagging. See also &quot;TAG ENTRIES&quot;.

              NROLES The number of roles this kind has. See also &quot;Roles&quot;.

              MASTER The master parser controlling enablement of the kind.  A kind belongs to a language (owner) in Universal-ctags;  enabling
                     and disabling a kind in a language has no effect on a kind in another language even if both kinds has the same one-letter
                     flag and/or the same long-name flag. In other words, the namespace of kinds are separated by language.

                     However, Exuberant-ctags does not separate the kinds of C and C++. Enabling/disabling kindX in  C  language  enables/dis‐
                     ables  a  kind  in C++ language having the same long-name flag with kindX. To emulate this behavior in Universal-ctags, a
                     concept named &quot;master parser&quot; is introduced. Enabling/disabling some kinds are synchronized under the control of a master
                     language.

                        $ ctags --kinds-C=+'{local}' --list-kinds-full \
                          | grep -E '^(#|C\+\+ .* local)'
                        #LANGUAGE  LETTER NAME   ENABLED REFONLY NROLES MASTER DESCRIPTION
                        C++        l      local  yes     no      0      C      local variables
                        $ ctags --kinds-C=-'{local}' --list-kinds-full \
                          | grep -E '^(#|C\+\+ .* local)'
                        #LANGUAGE  LETTER NAME   ENABLED REFONLY NROLES MASTER DESCRIPTION
                        C++        l      local  no      no      0      C      local variables

                     You see &quot;ENABLED&quot; field of &quot;local&quot; kind of C++ language is changed Though &quot;local&quot; kind of C language is enabled/disabled.
                     If you swap the languages, you see the same result.

              DESCRIPTION
                     Human readable description for the kind.

       --list-languages
              Lists the names of the languages understood by ctags, and then exits. These language names are case insensitive and may be  used
              in many other options like --language-force, --languages, --kinds-&lt;LANG&gt;, --regex-&lt;LANG&gt;, and so on.

              Each language listed is disabled if followed by &quot;[disabled]&quot;.  To use the parser for such a language, specify the language as an
              argument of --languages=+ option.

              This option does not work with --machinable nor --with-list-header.

       --list-map-extensions[=language|all]
              Lists the file extensions which associate a file name with a language for either the specified language or  all  languages,  and
              then exits.  all is used as default value if the option argument is omitted.

       --list-map-patterns[=language|all]
              Lists the file name patterns which associate a file name with a language for either the specified language or all languages, and
              then exits.  all is used as default value if the option argument is omitted.

       --list-maps[=language|all]
              Lists file name patterns and the file extensions which associate a file name with a language for either the  specified  language
              or  all languages, and then exits. See the --langmap option, and &quot;SOURCE FILES&quot;, above.  all is used as default value if the op‐
              tion argument is omitted.

              To list the file extensions or file name patterns individually, use --list-map-extensions or  --list-map-patterns  option.   See
              the --langmap option, and &quot;SOURCE FILES&quot;, above.

              This option does not work with --machinable nor --with-list-header.

       --list-mline-regex-flags
              Output list of flags which can be used in a multiline regex parser definition.

       --list-params[=language|all]
              Lists  the  parameters  for either the specified language or all languages, and then exits.  all is used as default value if the
              option argument is omitted.

       --list-pseudo-tags
              Output list of pseudo tags.

       --list-regex-flags
              See ctags-optlib(7).

       --list-roles[=language|all[.kinds]]
              List the roles for either the specified language or all languages.  all is used as default value if the option argument is omit‐
              ted.   If  the parameter kinds is given after the parameter language or all with concatenating with '.', list only roles defined
              in the kinds. Both one-letter flags and long name flags surrounded by braces are acceptable as the parameter kinds.

              The meaning of columns are as follows:

              LANGUAGE
                     The name of language having the role.

              KIND(L/N)
                     The one-letter flag and the long-name flag of kind having the role.

              NAME   The long-name flag of the role.

              ENABLED
                     Whether the kind is enabled or not. It takes &quot;yes&quot; or &quot;no&quot;.  (Currently all roles are enabled. No option for disabling  a
                     specified role is not implemented yet.)

              DESCRIPTION
                     Human readable description for the role.

       --list-subparsers[=baselang|all]
              Lists the subparsers for a base language for either the specified baselang or all languages, and then exits.  all is used as de‐
              fault value if the option argument is omitted.

       --machinable[=yes|no]
              Use tab character as separators for --list- option output.  It may be suitable for scripting. See &quot;List options&quot; for  considered
              use cases. Disabled by default.

       --map-&lt;LANG&gt;=[+|-]extension|pattern
              This option provides the way to control mapping(s) of file names to languages in a more fine-grained way than --langmap option.

              In  ctags,  more  than  one language can map to a file name pattern or file extension (N:1 map). Alternatively, --langmap option
              handle only 1:1 map, only one language mapping to one file name pattern or file extension.  A typical N:1 map is seen in C++ and
              ObjectiveC language; both languages have a map to &quot;.h&quot; as a file extension.

              A file extension is specified by preceding the extension with a period (e.g. &quot;.c&quot;).  A file name pattern is specified by enclos‐
              ing the pattern in parentheses (e.g.  &quot;([Mm]akefile)&quot;). A prefixed plus ('+') sign is for adding, and minus ('-') is for  remov‐
              ing. No prefix means replacing the map of &lt;LANG&gt;.

              Unlike  --langmap, extension (or pattern) is not a list.  --map-&lt;LANG&gt; takes one extension (or pattern). However, the option can
              be specified with different arguments multiple times in a command line.

       --maxdepth=N
              Limits the depth of directory recursion enabled with the --recurse (-R) option.

       --mline-regex-&lt;LANG&gt;=/line_pattern/name_pattern/[flags]
              Define multiline regular expression for locating tags in specific language.

       --options=pathname
              Read additional options from file or directory.

              ctags searches pathname in optlib path list first. If ctags cannot find a file or directory in the list, ctags reads a  file  or
              directory at the specified pathname.

              If  a  file is specified, it should contain one option per line. If a directory is specified, files suffixed with &quot;.ctags&quot; under
              it are read in alphabetical order.

              As a special case, if &quot;--options=NONE&quot; is specified as the first option on the command line, preloading is disabled; the  option
              will disable the automatic reading of any configuration options from either a file or the environment (see &quot;FILES&quot;).

       --options-maybe=pathname
              Same as --options but doesn't cause an error if file (or directory) specified with pathname doesn't exist.

       --optlib-dir=[+]directory
              Add an optlib directory to or reset optlib path list.  By default, the optlib path list is empty.

       --output-encoding=encoding
              Specifies  the  encoding  of the tags file.  Universal-ctags converts the encoding of input files from the encoding specified by
              --input-encoding=encoding to this encoding.

              In addition encoding is specified at the top the tags file as the value for the TAG_FILE_ENCODING pseudo tag. The default  value
              of encoding is UTF-8.

       --output-format=u-ctags|e-ctags|etags|xref|json
              Specify  the  output format. The default is &quot;u-ctags&quot;.  See tags(5) for &quot;u-ctags&quot; and &quot;e-ctags&quot;.  See -e for &quot;etags&quot;, and -x for
              &quot;xref&quot;.  &quot;json&quot; is experimental format, and available only if the ctags executable is built with libjansson.  This  option  must
              appear before the first file name.

       --param-&lt;LANG&gt;:name=argument
              Set &lt;LANG&gt; specific parameter. Available parameters can be listed with --list-params.

       --pattern-length-limit=N
              Cutoff patterns of tag entries after N characters. Disable by setting to 0 (default is 96).

       --print-language
              Just prints the language parsers for specified source files, and then exits.

       --pseudo-tags=[+|-]ptag, --pseudo-tags=*
              Enable/disable emitting pseudo tag named ptag.  If * is given, enable emitting all pseudo tags.

       --put-field-prefix
              Put &quot;UCTAGS&quot; as prefix for the name of fields newly introduced in universal-ctags.

       --quiet[=yes|no]
              Write fewer messages (default is no).

       --recurse[=yes|no]
              Recurse  into directories encountered in the list of supplied files.  If the list of supplied files is empty and no file list is
              specified with the -L option, then the current directory (i.e. &quot;.&quot;) is assumed.  Symbolic links are followed. If you don't  like
              these  behaviors, either explicitly specify the files or pipe the output of find(1) into ctags -L- instead. Note: This option is
              not supported on all platforms at present. It is available if the output of the --help option includes this option.  See,  also,
              the --exclude and --maxdepth to limit recursion.

       --regex-&lt;LANG&gt;=/regexp/replacement/[kind-spec/][flags]
              See ctags-optlib(7).

       --sort[=yes|no|foldcase]
              Indicates  whether  the tag file should be sorted on the tag name (default is yes). Note that the original vi(1) required sorted
              tags.  The foldcase value specifies case insensitive (or case-folded) sorting.  Fast binary searches of tag  files  sorted  with
              case-folding  will  require special support from tools using tag files, such as that found in the ctags readtags library, or Vim
              version 6.2 or higher (using &quot;set ignorecase&quot;). This option must appear before the first file name. [Ignored in etags mode]

       --tag-relative[=yes|no|always|never]
              The yes value indicates that the file paths recorded in the tag file should be relative to  the  directory  containing  the  tag
              file,  rather  than relative to the current directory, unless the files supplied on the command line are specified with absolute
              paths. This option must appear before the first file name. The default is yes when running in etags mode (see the -e option), no
              otherwise.   The  always value indicates the recorded file paths should be relative even if source file names are passed in with
              absolute paths.  The never value indicates the recorded file paths should be absolute even if source file names  are  passed  in
              with relative paths.

       --totals[=yes|no]
              Prints  statistics  about  the source files read and the tag file written during the current invocation of ctags. This option is
              off by default. This option must appear before the first file name.

              The extra value prints parser specific statistics for parsers gathering such information.

       --use-slash-as-filename-separator[=yes|no]
              Uses slash character as filename separators instead of backslash character when printing input: field.  This option is available
              on MSWindows only.  The default is yes for the default &quot;u-ctags&quot; output format, and no for the other formats.

       --verbose[=yes|no]
              Enable  verbose mode. This prints out information on option processing and a brief message describing what action is being taken
              for each file considered by ctags. Normally, ctags does not read command line arguments until after options are  read  from  the
              configuration  files  (see  &quot;FILES&quot;, below) and the CTAGS environment variable. However, if this option is the first argument on
              the command line, it will take effect before any options are read from these sources. The default is no.

       --version
              Prints a version identifier for ctags to standard output, and then exits. This is guaranteed to always contain the string  &quot;Uni‐
              versal Ctags&quot;.

       --with-list-header[=yes|no]
              Print headers describing columns in --list- option output.  See also &quot;List options&quot;.

OPERATIONAL DETAILS
       As  ctags considers each file name in turn, it tries to determine the language of the file by applying the following three tests in or‐
       der: if the file extension has been mapped to a language, if the filename matches a shell pattern mapped to a language, and finally  if
       the  file  is executable and its first line specifies an interpreter using the Unix-style &quot;#!&quot; specification (if supported on the plat‐
       form). Additionally, if the --guess-language-eagerly option is given, heuristic testing is also performed to determine  if  a  language
       parser applies. (See &quot;Determining file language&quot;)

       If  a  language  was identified, the file is opened and then the appropriate language parser is called to operate on the currently open
       file. The parser parses through the file and adds an entry to the tag file for each language object it is written to handle.  See  &quot;TAG
       FILE FORMAT&quot;, below, for details on these entries.

       This  implementation of ctags imposes no formatting requirements on C code as do legacy implementations. Older implementations of ctags
       tended to rely upon certain formatting assumptions in order to help it resolve coding dilemmas caused by preprocessor conditionals.

       In general, ctags tries to be smart about conditional preprocessor directives. If a preprocessor conditional is  encountered  within  a
       statement which defines a tag, ctags follows only the first branch of that conditional (except in the special case of &quot;#if 0&quot;, in which
       case it follows only the last branch). The reason for this is that failing to pursue only one branch can result in ambiguous syntax, as
       in the following example:

          #ifdef TWO_ALTERNATIVES
          struct {
          #else
          union {
          #endif
                  short a;
                  long b;
          }

       Both branches cannot be followed, or braces become unbalanced and ctags would be unable to make sense of the syntax.

       If  the  application of this heuristic fails to properly parse a file, generally due to complicated and inconsistent pairing within the
       conditionals, ctags will retry the file using a  different  heuristic  which  does  not  selectively  follow  conditional  preprocessor
       branches,  but instead falls back to relying upon a closing brace (&quot;}&quot;) in column 1 as indicating the end of a block once any brace im‐
       balance results from following a #if conditional branch.

       ctags will also try to specially handle arguments lists enclosed in double sets of parentheses in order to accept the following  condi‐
       tional construct:
          extern void foo __ARGS((int one, char two));

       Any name immediately preceding the &quot;((&quot; will be automatically ignored and the previous name will be used.

       C++  operator  definitions are specially handled. In order for consistency with all types of operators (overloaded and conversion), the
       operator name in the tag file will always be preceded by the string &quot;operator &quot; (i.e. even if the actual operator definition was  writ‐
       ten as &quot;operator&lt;&lt;&quot;).

       After creating or appending to the tag file, it is sorted by the tag name, removing identical tag lines.

TAG FILE FORMAT
       When  not  running  in  etags  mode, each entry in the tag file consists of a separate line, each looking like this in the most general
       case:

       tag_name&lt;TAB&gt;file_name&lt;TAB&gt;ex_cmd;&quot;&lt;TAB&gt;extension_fields

       The fields and separators of these lines are specified as follows:

          1. tag name

          2. single tab character

          3. name of the file in which the object associated with the tag is located

          4. single tab character

          5. EX command used to locate the tag within the file; generally a search pattern (either /pattern/ or ?pattern?) or line number (see
             --excmd).  Tag  file  format  2  (see --format) extends this EX command under certain circumstances to include a set of extension
             fields (described below) embedded in an EX comment immediately appended to the EX command, which  leaves  it  backward-compatible
             with original vi(1) implementations.

       A few special tags are written into the tag file for internal purposes.  These tags are composed in such a way that they always sort to
       the top of the file. Therefore, the first two characters of these tags are used a magic number to detect a tag file for purposes of de‐
       termining whether a valid tag file is being overwritten rather than a source file.

       Note  that  the  name of each source file will be recorded in the tag file exactly as it appears on the command line. Therefore, if the
       path you specified on the command line was relative to the current directory, then it will be recorded in that same manner in  the  tag
       file. See, however, the --tag-relative option for how this behavior can be modified.

       Extension  fields  are  tab-separated key-value pairs appended to the end of the EX command as a comment, as described above. These key
       value pairs appear in the general form &quot;key:value&quot;. Their presence in the lines of the tag file are controlled by the --fields  option.
       The possible keys and the meaning of their values are as follows:

       access Indicates the visibility of this class member, where value is specific to the language.

       file   Indicates that the tag has file-limited visibility. This key has no corresponding value.

       kind   Indicates  the  type, or kind, of tag. Its value is either one of the corresponding one-letter flags described under the various
              --kinds-&lt;LANG&gt; options above, or a long-name flag. It is permitted (and is, in fact, the default) for the key  portion  of  this
              field to be omitted. The optional behaviors are controlled with the --fields option.

       implementation
              When present, this indicates a limited implementation (abstract vs.  concrete) of a routine or class, where value is specific to
              the language (&quot;virtual&quot; or &quot;pure virtual&quot; for C++; &quot;abstract&quot; for Java).

       inherits
              When present, value. is a comma-separated list of classes from which this class is derived (i.e. inherits from).

       signature
              When present, value is a language-dependent representation of the signature of a routine. A routine signature  in  its  complete
              form  specifies the return type of a routine and its formal argument list.  This extension field is presently supported only for
              C-based languages and does not include the return type.

       In addition, information on the scope of the tag definition may be available, with the key portion  equal  to  some  language-dependent
       construct  name  and  its value the name declared for that construct in the program.  This scope entry indicates the scope in which the
       tag was found.  For example, a tag generated for a C structure member would have a scope looking like &quot;struct:myStruct&quot;.

HOW TO USE WITH VI
       Vi will, by default, expect a tag file by the name &quot;tags&quot; in the current directory. Once the tag file is built, the following  commands
       exercise the tag indexing feature:

       vi -t tag
              Start vi and position the cursor at the file and line where &quot;tag&quot; is defined.

       :ta tag
              Find a tag.

       Ctrl-] Find the tag under the cursor.

       Ctrl-T Return to previous location before jump to tag (not widely implemented).

HOW TO USE WITH GNU EMACS
       Emacs  will,  by default, expect a tag file by the name &quot;TAGS&quot; in the current directory. Once the tag file is built, the following com‐
       mands exercise the tag indexing feature:

       M-x visit-tags-table &lt;RET&gt; FILE &lt;RET&gt;
              Select the tag file, &quot;FILE&quot;, to use.

       M-. [TAG] &lt;RET&gt;
              Find the first definition of TAG. The default tag is the identifier under the cursor.

       M-*    Pop back to where you previously invoked &quot;M-.&quot;.

       C-u M-.
              Find the next definition for the last tag.

       For more commands, see the Tags topic in the Emacs info document.

HOW TO USE WITH NEDIT
       NEdit version 5.1 and later can handle the new extended tag file format (see  --format).  To  make  NEdit  use  the  tag  file,  select
       &quot;File-&gt;Load  Tags  File&quot;.  To  jump to the definition for a tag, highlight the word, then press Ctrl-D. NEdit 5.1 can read multiple tag
       files from different directories. Setting the X resource nedit.tagFile to the name of a tag file instructs NEdit to automatically  load
       that tag file at startup time.

CAVEATS
       Because  ctags  is neither a preprocessor nor a compiler, use of preprocessor macros can fool ctags into either missing tags or improp‐
       erly generating inappropriate tags. Although ctags has been designed to handle certain common cases, this is the single  biggest  cause
       of  reported  problems.  In  particular, the use of preprocessor constructs which alter the textual syntax of C can fool ctags. You can
       work around many such problems by using the -I option.

       Note that since ctags generates patterns for locating tags (see the --excmd option), it is entirely possible that the wrong line may be
       found  by  your  editor  if  there  exists another source line which is identical to the line containing the tag. The following example
       demonstrates this condition:

          int variable;

          /* ... */
          void foo(variable)
          int variable;
          {
                  /* ... */
          }

       Depending upon which editor you use and where in the code you happen to be, it is possible that the search pattern may locate the local
       parameter  declaration in foo() before it finds the actual global variable definition, since the lines (and therefore their search pat‐
       terns are identical).  This can be avoided by use of the --excmd=n option.

BUGS
       ctags has more options than ls(1).

       When parsing a C++ member function definition (e.g. &quot;className::function&quot;), ctags cannot determine whether the  scope  specifier  is  a
       class  name  or  a namespace specifier and always lists it as a class name in the scope portion of the extension fields. Also, if a C++
       function is defined outside of the class declaration (the usual case), the access specification (i.e. public,  protected,  or  private)
       and  implementation information (e.g. virtual, pure virtual) contained in the function declaration are not known when the tag is gener‐
       ated for the function definition. It will, however be available for prototypes (e.g. &quot;--kinds-c++=+p&quot;).

       No qualified tags are generated for language objects inherited into a class.

ENVIRONMENT VARIABLES
       CTAGS  If this environment variable exists, it will be expected to contain a set of default options which are read when  ctags  starts,
              after  the configuration files listed in FILES, below, are read, but before any command line options are read. Options appearing
              on the command line will override options specified in this variable.  Only options will be read from this variable.  Note  that
              all  white  space in this variable is considered a separator, making it impossible to pass an option parameter containing an em‐
              bedded space. If this is a problem, use a configuration file instead.

       ETAGS  Similar to the CTAGS variable above, this variable, if found, will be read when etags starts. If this  variable  is  not  found,
              etags will try to use CTAGS instead.

       TMPDIR On  Unix-like hosts where mkstemp() is available, the value of this variable specifies the directory in which to place temporary
              files.  This can be useful if the size of a temporary file becomes too large to fit on the partition holding the default  tempo‐
              rary  directory  defined  at compilation time. ctags creates temporary files only if either (1) an emacs-style tag file is being
              generated, (2) the tag file is being sent to standard output, or (3) the program was compiled to use an internal sort  algorithm
              to sort the tag files instead of the sort utility of the operating system.  If the sort utility of the operating system is being
              used, it will generally observe this variable also. Note that if ctags is setuid, the value of TMPDIR will be ignored.

FILES
       $XDG_CONFIG_HOME/ctags/*.ctags, or $HOME/.config/ctags/*.ctags if $XDG_CONFIG_HOME is not defeind (on other than MSWindows)

       $HOME/.ctags.d/*.ctags

       $HOMEDRIVE$HOMEPATH/ctags.d/*.ctags (on MSWindows only)

       .ctags.d/*.ctags

       ctags.d/*.ctags
          If any of these configuration files exist, each will be expected to contain a set of default options which are  read  in  the  order
          listed when ctags starts, but before the CTAGS environment variable is read or any command line options are read. This makes it pos‐
          sible to set up personal or project-level defaults. It is possible to compile ctags to read an additional configuration file  before
          any  of  those  shown above, which will be indicated if the output produced by the --version option lists the &quot;custom-conf&quot; feature.
          Options appearing in the CTAGS environment variable or on the command line will override options specified in these files. Only  op‐
          tions  will  be  read  from  these  files. Note that the option files are read in line-oriented mode in which spaces are significant
          (since shell quoting is not possible) but spaces at the beginning of a line are ignored. Each line of the file is read as  one  com‐
          mand  line  parameter  (as  if it were quoted with single quotes).  Therefore, use new lines to indicate separate command-line argu‐
          ments.  A line starting with '#' is treated as a comment.

          *.ctags files in a directory are loaded in alphabetical order.

       tags   The default tag file created by ctags.

       TAGS   The default tag file created by etags.

SEE ALSO
       See ctags-optlib(7) for defining (or extending) a parser in a configuration file.

       See tags(5) for the format of tag files.

       The official Universal-ctags web site at:

       <a href="https://ctags.io/">https://ctags.io/</a>

       Also ex(1), vi(1), elvis, or, better yet, vim, the official editor of ctags.  For more information on vim, see the VIM Pages  web  site
       at:

       <a href="https://www.vim.org/">https://www.vim.org/</a>

AUTHOR
       Universal-ctags project <a href="https://ctags.io/">https://ctags.io/</a>

       Darren Hiebert &lt;dhiebert@users.sourceforge.net&gt; <a href="http://DarrenHiebert.com/">http://DarrenHiebert.com/</a>

MOTIVATION
       &quot;Think ye at all times of rendering some service to every member of the human race.&quot;

       &quot;All  effort  and exertion put forth by man from the fullness of his heart is worship, if it is prompted by the highest motives and the
       will to do service to humanity.&quot;

       -- From the Baha'i Writings

CREDITS
       This version of ctags (Universal-ctags) derived from the repository, known as fishman-ctags, started by Reza Jelveh.

       Some parsers are taken from tagmanager of Geany (<a href="https://www.geany.org/)">https://www.geany.org/)</a> project.

       The fishman-ctags was derived from Exuberant-ctags.

       Exuberant-ctags was originally derived from and inspired by the ctags program by Steve Kirkendall &lt;kirkenda@cs.pdx.edu&gt; that comes with
       the Elvis vi clone (though virtually none of the original code remains).

       Credit  is also due Bram Moolenaar &lt;Bram@vim.org&gt;, the author of vim, who has devoted so much of his time and energy both to developing
       the editor as a service to others, and to helping the orphans of Uganda.

       The section entitled &quot;HOW TO USE WITH GNU EMACS&quot; was shamelessly stolen from the info page for GNU etags.

0.0.0                                                                                                                                 CTAGS(1)
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
